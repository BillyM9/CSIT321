<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BDI Blocks World</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f8fafc;
      color: #111827;
    }

    .sidebar {
      position: fixed;
      left: 0; top: 0; bottom: 0;
      width: 220px;
      background: #4FD1C5;
      color: white;
      padding: 25px 20px;
    }

    .sidebar h2 {
      font-size: 20px;
      margin-bottom: 20px;
    }

    .sidebar nav p {
      margin: 12px 0;
      cursor: pointer;
    }

    .main {
      margin-left: 220px;
      padding: 20px;
    }

    .header {
      background: #4FD1C5;
      padding: 20px 30px;
      border-radius: 12px;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 25px;
    }

    .user-info {
      display: flex;
      align-items: center;
    }

    .user-info img {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      margin-right: 10px;
    }

    .canvas-card {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.05);
      margin-bottom: 30px;
    }

    canvas {
      display: block;
      margin: auto;
      border: 2px solid #e5e7eb;
      background: #fff;
    }

    .panels {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
    }

    .panel {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.04);
    }

    .panel h3 {
      margin-top: 0;
      margin-bottom: 15px;
      color: #0f172a;
    }

    .button {
      padding: 10px;
      border: none;
      border-radius: 6px;
      color: white;
      width: 100%;
      margin-bottom: 10px;
      font-weight: bold;
      cursor: pointer;
    }

    .btn-send { background: #4FD1C5; }
    .btn-add { background: #38B2AC; }
    .btn-reset { background: #319795; }

    input[type="text"] {
      width: 100%;
      padding: 10px;
      margin-bottom: 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
    }

    .log {
      font-size: 13px;
      max-height: 150px;
      overflow-y: auto;
      background: #f1f5f9;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }

    .status {
      font-size: 14px;
    }
  </style>
</head>
<body>

  <div class="sidebar">
    <h2>BDI Blocks World</h2>
    <nav>
      <p>Simulation</p>
      <p>History</p>
      <hr style="border-color: #ffffff44;">
      <p>Profile</p>
      <p>Sign In</p>
      <p>Sign Up</p>
    </nav>
  </div>

  <div class="main">
    <div class="header">
      <div>Simulation</div>
      <div class="user-info">
        <img src="https://i.pravatar.cc/100" alt="User"/>
        <span>Lord Farquad</span>
      </div>
    </div>

    <div class="canvas-card">
      <canvas id="simCanvas" width="600" height="350"></canvas>
    </div>

    <div class="panels">
      <div class="panel">
        <h3>Control Panel</h3>
        <input id="goalInput" type="text" placeholder="e.g. A on B">
        <button class="button btn-send" onclick="sendGoal()">Send Goal</button>
        <button class="button btn-add" onclick="addBlock()">Add Block</button>
        <button class="button btn-reset" onclick="resetBlocks()">Reset</button>
      </div>

      <div class="panel">
        <h3>Status</h3>
        <div class="status" id="status">Waiting for goal...</div>
      </div>

      <div class="panel">
        <h3>Log</h3>
        <div class="log" id="logBox"></div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("simCanvas");
    const ctx = canvas.getContext("2d");
    const blockSize = 50;
    let positions = {};
    let nextX = 80;
    let currentBlockCharCode = "A".charCodeAt(0);

    let beliefs = {
      blocks: {},
      holding: null
    };

    let armX = 100, armY = 0, holdingBlock = null;
    let armTargetX = null, armTargetY = null;
    let actionQueue = [];
    let currentAction = null;

    const ws = new WebSocket("ws://localhost:8080");

    ws.onopen = () => {
      log("✅ Client connected to BDI WebSocket server.");
    };

    ws.onerror = (error) => {
      log("❌ WebSocket error: Could not connect to server.");
      console.error("WebSocket Error:", error);
    };

    ws.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.type === "plan") {
        log(`📦 Plan received: ${JSON.stringify(msg.plan)}`);
        actionQueue = msg.plan.map(([type, ...args]) => ({ type, args }));
        runNextAction();
      }
    };

    function log(text) {
      const logBox = document.getElementById("logBox");
      logBox.innerHTML += text + "<br>";
      logBox.scrollTop = logBox.scrollHeight;
    }

    function sendGoal() {
      const goalText = document.getElementById("goalInput").value.trim();
      if (!goalText.includes(" on ")) {
        alert("Goal must be in format: A on B");
        return;
      }
      ws.send(JSON.stringify({ type: "goal", goal: goalText }));
      document.getElementById("status").textContent = `🎯 Goal sent: ${goalText}`;
    }

    function runNextAction() {
      if (actionQueue.length === 0) {
        document.getElementById("status").innerHTML = "✅ <span style='color:#4FD1C5;'>Goal complete.</span>";
        return;
      }

      currentAction = actionQueue.shift();
      const { type, args } = currentAction;

      if (type === "pickup") {
        const block = args[0];
        armTargetX = positions[block] + blockSize / 2;
        armTargetY = 300 - blockSize * getBlockLevel(block);
        holdingBlock = block; 
      } else if (type === "putdown") {
        const [block, dest] = args;
        armTargetX = positions[dest] + blockSize / 2;
        armTargetY = 300 - blockSize * (getNextStackLevel(dest) + 1); 
      }
    }

    function updateArmPosition() {
      if (!currentAction) return;

      const speed = 4;
      if (Math.abs(armX - armTargetX) > speed) {
        armX += armX < armTargetX ? speed : -speed;
      }
      if (Math.abs(armY - armTargetY) > speed) {
        armY += armY < armTargetY ? speed : -speed;
      }

      if (Math.abs(armX - armTargetX) <= speed && Math.abs(armY - armTargetY) <= speed) {
        const { type, args } = currentAction;

        if (type === "putdown") {
          const [block, base] = args;
          beliefs.blocks[block] = base;
          positions[block] = positions[base]; 
          holdingBlock = null;
        } else if (type === "pickup") {
          const [block] = args;
          beliefs.blocks[block] = null;
        }

        currentAction = null;
        setTimeout(runNextAction, 300);
      }
    }

    function getBlockLevel(block) {
      let level = 0;
      let under = beliefs.blocks[block];
      while (under && under !== "table") {
        level++;
        under = beliefs.blocks[under];
      }
      return level;
    }

    function getNextStackLevel(base) {
      let level = 0;
      let onTop = Object.keys(beliefs.blocks).find(k => beliefs.blocks[k] === base);
      while (onTop) {
        level++;
        onTop = Object.keys(beliefs.blocks).find(k => beliefs.blocks[k] === onTop);
      }
      return level;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      ctx.moveTo(0, 300);
      ctx.lineTo(canvas.width, 300);
      ctx.strokeStyle = "#999";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(armX, 0);
      ctx.lineTo(armX, armY);
      ctx.strokeStyle = "black";
      ctx.lineWidth = 4;
      ctx.stroke();

      const drawn = new Set();
      const allBlocks = Object.keys(positions);
      const supportedBlocks = Object.values(beliefs.blocks);
      const topBlocks = allBlocks.filter(b => !supportedBlocks.includes(b));

      for (const top of topBlocks) {
        if (top === holdingBlock || drawn.has(top)) continue;

        const stack = [];
        let current = top;

        while (current && beliefs.blocks[current] && beliefs.blocks[current] !== 'table') {
          stack.push(current);
          drawn.add(current);
          current = beliefs.blocks[current];
        }

        if (current && !drawn.has(current)) {
          stack.push(current);
          drawn.add(current);
        }

        stack.reverse().forEach((b, i) => {
          const x = positions[b];
          const y = 300 - blockSize * (i + 1);
          ctx.fillStyle = "#4FD1C5";
          ctx.fillRect(x, y, blockSize, blockSize);
          ctx.fillStyle = "white";
          ctx.fillText(b, x + 20, y + 30);
        });
      }

      if (holdingBlock) {
        ctx.fillStyle = "orange";
        ctx.fillRect(armX - 25, armY, blockSize, blockSize);
        ctx.fillStyle = "black";
        ctx.fillText(holdingBlock, armX - 5, armY + 30);
      }
    }

    function animate() {
      updateArmPosition();
      draw();
      requestAnimationFrame(animate);
    }

    function resetBlocks() {
      beliefs = { blocks: {}, holding: null };
      positions = {};
      nextX = 80;
      currentBlockCharCode = "A".charCodeAt(0);
      armX = 100;
      armY = 0;
      holdingBlock = null;
      actionQueue = [];
      currentAction = null;
      document.getElementById("status").textContent = "🔄 Reset complete.";
      log("🔁 Environment reset.");
    }

    function addBlock() {
      if (currentBlockCharCode > "Z".charCodeAt(0)) {
        alert("All alphabet blocks (A–Z) have been added.");
        return;
      }

      const name = String.fromCharCode(currentBlockCharCode);
      if (positions[name]) {
        alert(`Block ${name} already exists.`);
        return;
      }

      beliefs.blocks[name] = "table";
      positions[name] = nextX;
      nextX += 100;
      currentBlockCharCode++;

      log(`➕ Added block: ${name}`);
    }

    animate();
  </script>

</body>
</html>
